{"pages":[{"title":"UDOO Key Docs","text":"","tags":"","url":"index.html"},{"title":"Introduction","text":"UDOO KEY The UDOO KEY is a fully programmable board combining Raspberry Pi RP2040 microcontroller and ESP32-WROVER-E module from Espressif, coming together into a single, powerful solution of just 130 x 40 x 10.9 mm. UDOO KEY allows you to either use these two MCUs independently or to combine them, exploiting their unique features to realize infinite new applications. The Pico-compatible part of the UDOO KEY is built upon an RP2040 microcontroller by Raspberry Pi Foundation, dual Arm Cortex-M0+, with a QSPI 8MB Flash, a 133MHz clock and 264KB of on-chip SRAM. It is especially suitable for machine learning, motor control, and audio applications. The fully programmable ESP32 module, on the other hand, is an ESP32-WROVER-E based on a dual-core Xtensa 32-bit LX6, with a 16MB flash memory and an 8MB PSRAM. The ESP32 on board is also a Wi-Fi, Bluetooth and Bluetooth Low Energy module, thus providing the UDOO KEY with full wireless connectivity. The two microcontrollers can communicate via serial port or SWD interface. Both can be programmed using different environments, such as TinyML, TensorFlow Lite, MicroPython, C\/C++, Arduino IDE, and many more, giving you plenty of options to streamline your AI application. The UDOO KEY is also designed to natively support Clea, the AI platform by SECO Mind for deploying AI models and applications over a fleet of IoT devices through over-the-air updates. Download the User Manual to have a more complete explanation of the UDOO KEY hardware and features. Visit the Get Started - ESP32 and Get Started - RP2040 sections to learn how to start using your UDOO KEY. Lineup The UDOO KEY retail line up consists of two models, which are mainly distinguished by the availability of on-board sensors: UDOO KEY Basic UDOO KEY Pro Check the Board Versions section to see the differences between the two. Moreover, by looking at the following video, you can have a brief overview of the UDOO board and its components. Technical specifications Power supply: 5V DC Dimensions: 130 x 40 x 10.9 mm Sensors: On-chip temperature sensor 9-axis IMU motion sensor (only on UDOO KEY Pro) Omnidirectional Digital Microphone (only on UDOO KEY Pro) Microcontrollers ESP32 RP2040 Memory size 8 MB SPI Pseudo static RAM 264 KB SPI Pseudo static RAM Flash size 16 MB internal SPI flash 64 M-bit external QSPI flash Connectivity Wi-Fi 802.11 b\/g\/n (802.11n up to 150 Mbps), Bluetooth v4.2 BR\/EDR and BLE specification - Peripherals UEXT connector (I2C, SPI, UART) 26 multifunction GPIO pins Community Official web site: www.udoo.org Official forum: www.udoo.org\/forum Forums The official UDOO forums can be found at www.udoo.org\/forum The forum search facility has been tweaked to allow more general searching. Please do a search before making a post as the issue may already have been raised and answered. IRC channel There is an (unofficial) UDOO discussion channel on IRC. Using the IRC client of your choice, use server information: irc.freenode.net. Room name is #udoo. Social networks Facebook page Telegram group YouTube Twitter Google+","tags":"","url":"Introduction\/Introduction.html"},{"title":"Overview","text":"Hardware reference Overview In the above image is represented the name of on-board components used in following sections and in the schematic file. Following the role of each component. Name Description CN1 USB type-C connector P1, P2 RP2040 external connectors P3 UEXT connector to ESP32 P4 I\u00b2C select jumper P5 External SWD connector to RP2040 JP1 USB select jumper JP2 Boot mode selector ESP32 SW1, SW2, SW3 Switch buttons D12, D17, D18 LEDs Block diagram","tags":"","url":"Hardware_References\/Overview.html"},{"title":"Full specs","text":"Full Specifications Below the full technical specifications ESP32 RP2040 Memory 8 MB PSRAM 264 KB PSRAM Flash storage 16 MB internal SPI flash 64M-bit external QSPI flash Connectivity Wi-Fi 802.11 b\/g\/n (802.11n up to 150 Mbps), Bluetooth v4.2 BR\/EDR and BLE specification - RF power WiFi: 20 dBm, BT:13.7 dBM - Modulation type GFSK, OFDM - Frequency bands 2400 \u00f7 2483.5 MHz - Bandwidth BT \/ BLE: 1 MHz (79 channels) \/ 2 MHz (40 channels) - Peripherals UART, I\u00b2C, SPI on UEXT connector, blue and yellow LEDS, SWD lines to RP2040 UART, SPI, I\u00b2C on P1 and P2 , green LED Sensors SPK0838HT4H-1 Microphone, shared ICM-20948 IMU Shared ICM-20948 IMU Operating temperature: 0\u00b0C \u00f7 +60\u00b0C Power supply: +5VDC Dimensions: 130 x 40 x 10.9 mm Resources In addition to this guide, several ones are available online: for a full explanation of the UDOO KEY hardware download the UDOO KEY User Manual see the Get Started - ESP32 and Get Started - RP2040 sections for all the useful information for a quick installation here you can find the schematics file for the UDOO KEY official ESP32 development framework Raspberry PI PICO datasheet Raspberry PI PICO C\/C++ SDK MicroPython download page for RP2040 Board versions The UDOO KEY is available in two versions: UDOO KEY Basic and UDOO KEY Pro. The UDOO KEY Basic mounts no sensors, it is therefore perfect for those who want full control of their project, as it allows expansion with modules of developer\u2019s choice. The UDOO KEY Pro mounts two powerful sensors: a 9-axis IMU and a digital microphone. The 9-axis IMU motion sensor, an ICM-20948, combines an accelerometer, a magnetometer and a gyroscope in a single module to streamline a wide array of projects, from robotics and RC cars up to smart bikes and automation. It is connected to the ESP32 via I2C bus. You can decide whether to access the I2C bus via ESP32 or RP2040 through the jumper switch. The omnidirectional digital microphone, a SPK0838HT4H, is designed for AI-powered sound &amp; voice recognition as well as audio control. It is connected to the ESP32 via I2S bus. The following table and picture summarize the differences between the UDOO KEY Basic and the UDOO KEY Pro. UDOO KEY Basic UDOO KEY Pro Sensors on chip temperature sensor (RP2040) on chip temperature sensor (RP2040) 9-AXIS IMU motion sensors omnidirectional digital microphone Notice that, only for kickstarters, the IMU sensor has been changed and is currently installed the model MPU-6500, a 6-axis motion tracking sensor. Board headers The UDOO KEY features four useful pinout header. The pin header connector P3 on the top of the board is compliant with the UEXT specification and is accessible from the ESP32. It exposes the I2C, UART, and SPI interfaces. The two headers on the bottom of the board, P1 and P2, are 100% compatible with Raspberry Pi Pico, both hardware and software-wise \u2013 except for two GPIO pins used for UART mapping, namely GP0 and GP1, to ensure the communication between the ESP32 and the RP2040. This means that each and any expansion hardware as well as software built for Raspberry Pi Pico will work out of the box on the UDOO KEY. Finally, on P5 header are connected SWD lines (SWDCLK, GND and SWDIO) to easly program the RP2040, as for the Raspberry Pi Pico. Power source The UDOO KEY can be powered by an external power supply of +5V DC (max 2.5A) via USB Type-C connector (C1). The board is also provided with a 2.5A 32V DC fuse to protect itself from overcurrent injection. The USB Type-C connector powers up both the ESP32-WROVER-E module and the RP2040, and all peripherals connected on. The UDOO KEY can go into deep sleep, reducing the power consumption to a minimum. In this state it only awakes if triggered by a specific event, thus extending battery life up to several years.","tags":"","url":"Hardware_References\/Full_specs.html"},{"title":"ESP32","text":"The UDOO KEY is powered by Espressif ESP32-WROVER-E MCU module, a powerful and versatile platform for Edge AI applications, ranging from low-power sensor networks to the most demanding tasks, such as voice encoding, music streaming and MP3 decoding. This module is provided with a PCB antenna. This fully programmable microcontroller is based on a dual-core Xtensa 32-bit LX6, with a 16 MB internal SPI flash memory, an additional 8 MB SPI Pseudo Static RAM (PSRAM), Wi-Fi and Bluetooth. The core of the module is the ESP32-D0WD-V3 chip, which is designed to be scalable and adaptive. It features two CPU cores that can be individually controlled, and the CPU clock frequency is adjustable from 80 MHz to 240 MHz. The chip is also provided with a low-power co-processor that can be used instead of the CPU to save power while performing tasks that do not require much computing power, such as perihperals monitoring. Thanks to the ESP32 on board, you get full Wi-Fi 802.11b\/g\/n connectivity, Bluetooth and BLE v4.2. This ensures the UDOO KEY extreme versatility: the Wi-Fi allows to set up direct connection to the internet through a Wi-Fi router, while using the Bluetooth users can connect to their phones or broadcast low energy beacons for its detection. Note that the ESP32 on board is not just a Wi-Fi, BT &amp; BLE module. It gives you full access to the firmware of ESP32 and you can program it as you please. The sleep current of the ESP32 chip is less than 5 \u00b5A, making it suitable for battery powered and wearable electronics applications. The module supports a data rate of up to 150 Mbps, 802.11b at 13.5dBm, and 802.11g\/n at 18.5 dBm of output power to the antenna to ensure the widest physical range. The module thus offers industry-leading specifications and the best performance for electronic integration, range, power consumption, and connectivity. Secure (encrypted) over the air (OTA) upgrade is also supported, so that users can upgrade their products even after their release, at minimum cost and effort. For further information on Espressif ESP32, please refer to the dedicated page on espressif.com. In order to be able to interface the ESP32 with external integrated circuits, the target MCU is equipped with an UEXT connector following the pin map as reported in the table below. Pin number Schematic pin name ESP GPIO Description 1 3V3 - 3.3V output, 150mA max 2 GND - Power ground 3 EXT_UART2_TX GPIO13 UART transmission line 4 EXT_UART2_RX GPIO26 UART reception line 5 ESP32_SCL GPIO21 I\u00b2C clock line 6 ESP32_SDA GPIO18 I\u00b2C data line 7 SPI_MISO GPIO35 SPI Microcontroller in \/ Sensor out 8 SPI_MOSI GPIO12 SPI Microcontroller out \/ Sensor in 9 SPI_SCK GPIO14 SPI clock 10 SPI_CS GPIO15 SPI chip select","tags":"","url":"Hardware_References\/ESP32.html"},{"title":"RP2040","text":"The Pico-compatible part of the UDOO KEY is built upon a Raspberry Pi RP2040 microcontroller, dual Arm Cortex-M0+, with a QSPI 8MB Flash, a 133MHz clock and 264KB of on-chip SRAM. The RP2040 microcontroller is a chip from Raspberry Pi Foundation that integrates two Arm Cortex-M0+ CPUs that can be run up to 133MHz, featuring 264kB of on-chip SRAM and up to 16MB of off-chip Flash memory. This microcontroller can be used for machine learning, motor control, audio and so on. The UDOO KEY is 100% compatible with Raspberry Pi Pico both hardware and software-wise. This means that each and any expansion hardware as well as each and any software built for Raspberry Pi Pico will work out of the box on UDOO KEY. For further information on RP2040, please refer to the dedicated page on raspberrypi.com. P1 and P2 connectors of the Pico part can be used to connect external peripherals to the RP2040. Two 20-pin headers or castellated holes must be soldered on P1 and P2 in a proper manner to use them . The following tables summarize the possibilities offered by P1 and P2 connectors. P1 Pin number Schematic pin name SPI UART interface I\u00b2C PWM SIO\/PIO 1 N.C. - - - - - 2 N.C. - - - - - 3 GND - - - - - 4 RPI_SDA SPI0_SCK UART0_CTS I2C1_SDA PWM1_A SIO\/PIO0\/PIO1 5 RPI_SCL SPI0_TX UART0_RTS I2C1_SCL PWM1_B SIO\/PIO0\/PIO1 6 GP4 SPI0_RX UART1_TX I2C0_SDA PWM2_A SIO\/PIO0\/PIO1 7 GP5 SPI0_CSn UART1_RX I2C0_SCL PWM2_B SIO\/PIO0\/PIO1 8 GND - - - - - 9 GP6 SPI0_SCK UART1_CTS I2C1_SDA PWM3_A SIO\/PIO0\/PIO1 10 GP7 SPI0_TX UART1_RTS I2C1_SCL PWM3_B SIO\/PIO0\/PIO1 11 GP8 SPI1_RX UART1_TX I2C0_SDA PWM4_A SIO\/PIO0\/PIO1 12 GP9 SPI1_CSn UART1_RX I2C0_SCL PWM4_B SIO\/PIO0\/PIO1 13 GND - - - - - 14 GP10 SPI1_SCK UART1_CTS I2C1_SDA PWM5_A SIO\/PIO0\/PIO1 15 GP11 SPI1_TX UART1_RTS I2C1_SCL PWM5_B SIO\/PIO0\/PIO1 16 GP12 SPI1_RX UART0_TX I2C0_SDA PWM6_A SIO\/PIO0\/PIO1 17 GP13 SPI1_CSn UART0_RX I2C0_SCL PWM6_B SIO\/PIO0\/PIO1 18 GND - - - - - 19 GP14 SPI1_SCK UART0_CTS I2C1_SDA PWM7_A SIO\/PIO0\/PIO1 20 GP15 SPI1_TX UART0_RTS I2C1_SCL PWM7_B SIO\/PIO0\/PIO1 Pin number 1 and 2 are not connected since are used for MCUs communication. P2 Pin number Schematic pin name SPI UART interface I\u00b2C PWM SIO\/PIO 1 GP16 SPI0_RX UART0_TX I2C0_SDA PWM0_A SIO\/PIO0\/PIO1 2 GP17 SPI0_CSn UART0_RX I2C0_SCL PWM0_B SIO\/PIO0\/PIO1 3 GND - - - - - 4 GP18 SPI0_SCK UART0_CTS I2C1_SDA PWM1_A SIO\/PIO0\/PIO1 5 GP19 SPI0_TX UART0_RTS I2C1_SCL PWM1_B SIO\/PIO0\/PIO1 6 GP20 SPI0_RX UART1_TX I2C0_SDA PWM2_A SIO\/PIO0\/PIO1 7 GP21 SPI0_CSn UART1_RX I2C0_SCL PWM2_B SIO\/PIO0\/PIO1 8 GND - - - - - 9 GP22 SPI0_SCK UART1_CTS I2C1_SDA PWM3_A SIO\/PIO0\/PIO1 10 RPI_RESET - - - - - 11 GP26 SPI1_SCK UART1_CTS I2C1_SDA PWM5_A SIO\/PIO0\/PIO1 12 GP27 SPI1_TX UART1_RTS I2C1_SCL PWM5_B SIO\/PIO0\/PIO1 13 GND - - - - - 14 GP28 SPI1_RX UART0_TX I2C0_SDA PWM6_A SIO\/PIO0\/PIO1 15 ADC_VREF - - - - - 16 3V3 - - - - - 17 N.C. - - - - - 18 GND - - - - - 19 VSYS - - - - - 20 VBUS - - - - - Pin number: 10 is reserved for RP2040 reset by ESP32 16 provide 3.3V DC (315mA) in output 17 is not connected 19 provide 5V DC (500mA) filtered from USB Type-C connector (CN1) 20 provide 5V DC (500mA) raw from USB Type-C connector (CN1) P5 The Serial Wire Debug interface is available on the 1x3 poles connector P5. This header allows you to program and debug the RP2040 microcontroller externally. The following table shows the pin configuration. Pin number Function 1 SWCLK 2 GND 3 SWDIO","tags":"","url":"Hardware_References\/RP2040.html"},{"title":"MCUs connections","text":"To let you to create projects that leverage the power of both microcontrollers, they are connected through a serial connection. Such connection uses GPIO0 (TX) and GPIO1 (RX) on RP2040 and, on ESP32, IO19 (RX) and IO22 (TX). On schematic file those connections are labeled with RPI_UART_TX and RPI_UART_RX. Keep in mind that RP GPIO0 is connected to ESP IO19 and, vice versa, GPIO1 is connected with IO22. Thanks to this connection you can exchange between the MCUs whichever stream of bytes. There are cases in which the RP2040 must be restarted remotely: you can perform this operation from the ESP32. The pin number 10 on P2 header (RPI_RESET) is connected to ESP pin IO23. By setting its output level LOW the RP2040 execution is disabled, while, setting output level HIGH, the RP2040 execution is restored. So, to reset the Raspberry microcontroller from ESP, let's set the output level LOW and then move to HIGH. Moreover, to enable RP2040 OTA programming, its SWD lines are connected to ESP pins as shown in the following table. ESP GPIO NUM RP SWD interface IO2 SWDIO IO4 SWCLK Since the RP2040 can be programmed also through on-board SWD header P5, the user must ensure that, while he want to use such interface, the GPIO IO5 level is set to HIGH. To use external headers, such GPIO must be set to LOW level. Keep in mind that the IMU sensor is connected to both microcontrollers and, to select which of them can interact with it, a jumper must be inserted as explained in the following table. As explained in the schematic file, pin number 1 is the closest to the RP2040 and pin number 3 is the closest to the ESP32. Jumper position IMU Sensor connected to Not placed ESP32 (Default) Pin 1-2 RP2040 Pin 2-3 ESP32","tags":"","url":"Hardware_References\/MCUs_connections.html"},{"title":"Get started with ESP32","text":"After speaking a long about technical specifications and boards components, let's start doing things in order to load firmware in flash memory of microcontrollers! Now we will install all dependencies and frameworks, in Linux-based and Windows OSs, for ESP32 microcontroller and start programming it. The framework we chose is the official one, the ESP-IDF, but several other frameworks can be used to programming the ESP32. Among the others the most used are MicroPython and Arduino. Choose the one you prefer! Linux Here you can find the official documentation that explains with many more details the installation. For a quick guide read below! Additionally you can watch in the video below the full installation procedure explained and executed on a PC. In addition to following packages, a text editor is required: you can use VS Code or emacs or whatever you want! Open a terminal and type the following commands: # Install the essential dependencies sudo apt install cmake wget git python3 python3-pip virtualenv # Create the workspace folder (if it doesn't exist yet), clone the repository of ESP-IDF version 4.4.1 and install it mkdir ~\/ws\/esp cd ~\/ws\/esp git clone --recursive https:\/\/github.com\/espressif\/esp-idf.git -b 4.4.1 cd esp-idf bash install.sh esp32 # Before programming the ESP32, a set of environment variables need to be defined in the shell environment # Let's create an alias to easily load them and invoke it for each terminal you need cd ~ echo &quot;alias get_idf='. $HOME\/ws\/esp\/esp-idf\/export.sh'&quot; &gt;&gt; ~\/.bash_aliases source $HOME\/.bash_aliases get_idf # The environment is correctly loaded! It's the moment to create and load on your board the first program that makes the two on-board LEDs blink! Open a terminal and type: # First of all load the needed variables by calling the alias get_idf cd ~\/ws\/esp # Create the project idf.py create-project blinker cd blinker\/main Open the blinker.c file inside current folder and copy the content below inside it. It is the entry-point of your firmware and contains the instruction to perform the actions we want. #include &lt;stdio.h&gt; #include &lt;driver\/gpio.h&gt; #include &lt;freertos\/FreeRTOS.h&gt; #include &lt;freertos\/task.h&gt; #define B_LED_PIN GPIO_NUM_32 #define Y_LED_PIN GPIO_NUM_33 void led_blinker_task () { gpio_pad_select_gpio(B_LED_PIN); gpio_set_direction (B_LED_PIN, GPIO_MODE_OUTPUT); gpio_pad_select_gpio(Y_LED_PIN); gpio_set_direction (Y_LED_PIN, GPIO_MODE_OUTPUT); while (1) { gpio_set_level(Y_LED_PIN, 0); gpio_set_level(B_LED_PIN, 0); gpio_set_level(B_LED_PIN, 1); vTaskDelay(pdMS_TO_TICKS(128)); gpio_set_level(B_LED_PIN, 0); vTaskDelay(pdMS_TO_TICKS(128)); gpio_set_level(B_LED_PIN, 1); vTaskDelay(pdMS_TO_TICKS(128)); gpio_set_level(B_LED_PIN, 0); gpio_set_level(Y_LED_PIN, 1); vTaskDelay(pdMS_TO_TICKS(2000)); } } void app_main(void) { xTaskCreate (&amp;led_blinker_task, &quot;led_blinker_task&quot;, 1024, NULL, 2, NULL); } Now that everything is ready, you can build and flash the program. As explained in the video at the beginning of this page, you must leave the jumper JP1 opened to drive the serial communication to ESP microcontroller and then you can connect your board to PC. After the connection, a serial port appears on your file system. Its path can be \/dev\/ttyUSB0 or \/dev\/ttyUSB1 or \/dev\/ttyUSB2 and so on, depending if you already have connected serial devices. In the following commands, the port path is referred with &lt;PORT&gt; string. Finally you have to put the target MCU in flash mode, so close the jumper JP2 and push the button SW3 to reset it. The microcontroller can be programmed! To do that, in a terminal with environment variales already loaded, type the following commands: cd ~\/ws\/esp\/blinker idf.py -p &lt;PORT&gt; build flash monitor The above command will build the entire project (build command), will load the firmware into the ESP flash memory (flash command) and will monitor the output produced by the microcontroller and sent via the serial connection (monitor command). Keep in mind that you can also invoke build, flash, and monitor commands separately. Type the command idf.py help to get the full list of available commands. At this point the board need to be resetted to execute the just flashed firmware. Let's open the jumper JP2 and push the reset button SW3 to see LEDs in action! Windows For Windows OS installation, Espressif provides an installer which automatically performs everything. Firstly download the installer here and launch it. After the installation, you can open a ESP-IDF prompt by searching for ESP-IDF 4.4 CMD entry in the Start menu. Once launched, a new prompt is executed with the environment already loaded. If everything has been installed fine, you can create a project. To do that copy the code and flash the ESP32 in the same way explained for the Linux OS using an ESP-IDF command prompt. To obtain more information about the Windows OS, here you can find the official documentation.","tags":"","url":"Get_Started\/Get_started_with_ESP32.html"},{"title":"Get started with RP2040","text":"We will install all the dependencies, in both Linux-based and Windows OSs, to play with the MicroPython framework. We have chosen this development environment because it's easy to learn and has a great support from the community. As for the other on-board microcontroller, there exist several frameworks that support the RP2040. To write firmwares for the RP2040, you can use the official C\/C++ SDK, the Rust crate for the Pico board or the Arduino SDK. Choose the one you feel more comfortable with. We have recorded a video in which all steps described below are directly executed on a PC. Here a distinction between the Linux-based and Windows OSs is not needed, since MicroPython is host platform agnostic. First of all you need to install python3 and python3-pip, but they are already installed by following the guide for ESP32 part. You also need to install the rshell python package. It s needed to upload the python code and interact with the MicroPython interpreter running on the MCU. In a command line, type: python3 -m pip install rshell Now upload the MicroPython firmware into RP flash. Firstly, download its latest release from this page. Then put the microcontroller in flash mode: close the jumper JP1 to allow the computer to interact with RP and connect the board to your PC using an USB Type-C cable. Keep pressed the button SW2 labeled as BOOTSEL and push the reset button SW1. After these operations, the board is detected as a removable device by your computer. Simply copy the just downloaded .uf2 file and paste it into the removable drive. In this way you can program the Raspberry MCU! Once the MicroPython framework has been loaded, create a file called main.py and copy the following code on it. It will make the LED attached on pin 25 blink each 750 milliseconds! from machine import Pin import time LED_PIN=25 led = Pin(LED_PIN, Pin.OUT) while True : led.toggle () time.sleep (.750) To load the script on your board, move to the folder containing the main.py file using a command line (let's call it rp placed in ws folder), and type the following commands: cd ws\/rp # Invoke the rshell program rshell # It will automatically find the board, if correctly plugged # Now you can copy the main.py source file by copying it into \/pyboard folder which represent the connected board cp main.py \/pyboard\/main.py To apply changes, close the rshell program and reset the board with on-board button SW1. At this moment the LED will start blinking! To implement complex project using MicroPython you can find its official documentation here and the documentation for RP2040 specific functionalities here. Enjoy with your UDOO KEY!","tags":"","url":"Get_Started\/Get_started_with_RP2040.html"},{"title":"ESP accessories","text":"This chapter will come soon!","tags":"","url":"Compatible_Accessories\/ESP_accessories.html"},{"title":"RP accessories","text":"This chapter will come soon!","tags":"","url":"Compatible_Accessories\/RP_accessories.html"}]}